// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package sqlcpg

import (
	"context"
	"database/sql"
	"time"

	"github.com/fahmifan/smol/internal/rbac"
)

const countAllTodos = `-- name: CountAllTodos :one
SELECT COUNT(1) FROM todos WHERE user_id = $1
`

func (q *Queries) CountAllTodos(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countAllTodos, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteSessionByUserID = `-- name: DeleteSessionByUserID :one
DELETE FROM "sessions" WHERE user_id = $1
RETURNING id, user_id, access_token, access_token_expired_at, refresh_token, refresh_token_expired_at, created_at
`

func (q *Queries) DeleteSessionByUserID(ctx context.Context, userID string) (Session, error) {
	row := q.db.QueryRow(ctx, deleteSessionByUserID, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.AccessTokenExpiredAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiredAt,
		&i.CreatedAt,
	)
	return i, err
}

const findAllUserTodos = `-- name: FindAllUserTodos :many
SELECT id, detail, user_id, done FROM todos WHERE 
    user_id = $1
ORDER BY id ASC LIMIT $2
`

type FindAllUserTodosParams struct {
	UserID string
	Size   int32
}

func (q *Queries) FindAllUserTodos(ctx context.Context, arg FindAllUserTodosParams) ([]Todo, error) {
	rows, err := q.db.Query(ctx, findAllUserTodos, arg.UserID, arg.Size)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Detail,
			&i.UserID,
			&i.Done,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllUserTodosAsc = `-- name: FindAllUserTodosAsc :many
SELECT id, detail, user_id, done FROM todos WHERE 
    user_id = $1
    and id > $2
ORDER BY id ASC LIMIT $3
`

type FindAllUserTodosAscParams struct {
	UserID string
	Cursor string
	Size   int32
}

func (q *Queries) FindAllUserTodosAsc(ctx context.Context, arg FindAllUserTodosAscParams) ([]Todo, error) {
	rows, err := q.db.Query(ctx, findAllUserTodosAsc, arg.UserID, arg.Cursor, arg.Size)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Detail,
			&i.UserID,
			&i.Done,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllUserTodosDesc = `-- name: FindAllUserTodosDesc :many
SELECT id, detail, user_id, done FROM todos WHERE 
    user_id = $1
    and id < $2
ORDER BY id ASC LIMIT $3
`

type FindAllUserTodosDescParams struct {
	UserID string
	Cursor string
	Size   int32
}

func (q *Queries) FindAllUserTodosDesc(ctx context.Context, arg FindAllUserTodosDescParams) ([]Todo, error) {
	rows, err := q.db.Query(ctx, findAllUserTodosDesc, arg.UserID, arg.Cursor, arg.Size)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Detail,
			&i.UserID,
			&i.Done,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSessionByRefreshToken = `-- name: FindSessionByRefreshToken :one
SELECT id, user_id, access_token, access_token_expired_at, refresh_token, refresh_token_expired_at, created_at FROM sessions WHERE refresh_token = $1
`

func (q *Queries) FindSessionByRefreshToken(ctx context.Context, refreshToken string) (Session, error) {
	row := q.db.QueryRow(ctx, findSessionByRefreshToken, refreshToken)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.AccessTokenExpiredAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiredAt,
		&i.CreatedAt,
	)
	return i, err
}

const findTodoByID = `-- name: FindTodoByID :one
SELECT id, detail, user_id, done FROM todos WHERE id = $1
`

func (q *Queries) FindTodoByID(ctx context.Context, id string) (Todo, error) {
	row := q.db.QueryRow(ctx, findTodoByID, id)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Detail,
		&i.UserID,
		&i.Done,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, name, email, role FROM users WHERE email = $1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, name, email, role FROM users WHERE id = $1
`

func (q *Queries) FindUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
	)
	return i, err
}

const saveSession = `-- name: SaveSession :one

INSERT INTO "sessions" 
    (
        id, 
        user_id, 
        refresh_token_expired_at, 
        refresh_token, 
        access_token_expired_at, 
        access_token
    ) VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
RETURNING id, user_id, access_token, access_token_expired_at, refresh_token, refresh_token_expired_at, created_at
`

type SaveSessionParams struct {
	ID                    string
	UserID                string
	RefreshTokenExpiredAt time.Time
	RefreshToken          string
	AccessTokenExpiredAt  time.Time
	AccessToken           string
}

// Sessions
func (q *Queries) SaveSession(ctx context.Context, arg SaveSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, saveSession,
		arg.ID,
		arg.UserID,
		arg.RefreshTokenExpiredAt,
		arg.RefreshToken,
		arg.AccessTokenExpiredAt,
		arg.AccessToken,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.AccessTokenExpiredAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiredAt,
		&i.CreatedAt,
	)
	return i, err
}

const saveTodo = `-- name: SaveTodo :one

INSERT INTO todos 
    (id, 	user_id, detail,  done) VALUES
    ( $1,		 $2, 	 $3, 	$4)
RETURNING id, detail, user_id, done
`

type SaveTodoParams struct {
	ID     string
	UserID string
	Detail string
	Done   bool
}

// Todos
func (q *Queries) SaveTodo(ctx context.Context, arg SaveTodoParams) (Todo, error) {
	row := q.db.QueryRow(ctx, saveTodo,
		arg.ID,
		arg.UserID,
		arg.Detail,
		arg.Done,
	)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Detail,
		&i.UserID,
		&i.Done,
	)
	return i, err
}

const saveUser = `-- name: SaveUser :one

INSERT INTO 
"users" (id, name, email, role) 
VALUES ($1, $2, $3, $4)
RETURNING id, name, email, role
`

type SaveUserParams struct {
	ID    string
	Name  sql.NullString
	Email string
	Role  rbac.Role
}

// Users
func (q *Queries) SaveUser(ctx context.Context, arg SaveUserParams) (User, error) {
	row := q.db.QueryRow(ctx, saveUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
	)
	return i, err
}

const updateAccessToken = `-- name: UpdateAccessToken :one
UPDATE sessions SET access_token = $1, access_token_expired_at = $2 WHERE id = $3
RETURNING id, user_id, access_token, access_token_expired_at, refresh_token, refresh_token_expired_at, created_at
`

type UpdateAccessTokenParams struct {
	AccessToken          string
	AccessTokenExpiredAt time.Time
	ID                   string
}

func (q *Queries) UpdateAccessToken(ctx context.Context, arg UpdateAccessTokenParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateAccessToken, arg.AccessToken, arg.AccessTokenExpiredAt, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccessToken,
		&i.AccessTokenExpiredAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiredAt,
		&i.CreatedAt,
	)
	return i, err
}
